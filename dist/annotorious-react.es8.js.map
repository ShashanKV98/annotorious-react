{"version":3,"file":"annotorious-react.es8.js","sources":["../node_modules/@annotorious/core/dist/annotorious-core.es.js"],"sourcesContent":["var Y = Object.prototype.hasOwnProperty;\nfunction B(e, n) {\n  var t, o;\n  if (e === n)\n    return !0;\n  if (e && n && (t = e.constructor) === n.constructor) {\n    if (t === Date)\n      return e.getTime() === n.getTime();\n    if (t === RegExp)\n      return e.toString() === n.toString();\n    if (t === Array) {\n      if ((o = e.length) === n.length)\n        for (; o-- && B(e[o], n[o]); )\n          ;\n      return o === -1;\n    }\n    if (!t || typeof e == \"object\") {\n      o = 0;\n      for (t in e)\n        if (Y.call(e, t) && ++o && !Y.call(n, t) || !(t in n) || !B(e[t], n[t]))\n          return !1;\n      return Object.keys(n).length === o;\n    }\n  }\n  return e !== e && n !== n;\n}\nfunction $() {\n}\nfunction W(e, n) {\n  return e != e ? n == n : e !== n || e && typeof e == \"object\" || typeof e == \"function\";\n}\nconst k = [];\nfunction _(e, n = $) {\n  let t;\n  const o = /* @__PURE__ */ new Set();\n  function i(b) {\n    if (W(e, b) && (e = b, t)) {\n      const w = !k.length;\n      for (const u of o)\n        u[1](), k.push(u, e);\n      if (w) {\n        for (let u = 0; u < k.length; u += 2)\n          k[u][0](k[u + 1]);\n        k.length = 0;\n      }\n    }\n  }\n  function h(b) {\n    i(b(e));\n  }\n  function U(b, w = $) {\n    const u = [b, w];\n    return o.add(u), o.size === 1 && (t = n(i) || $), b(e), () => {\n      o.delete(u), o.size === 0 && t && (t(), t = null);\n    };\n  }\n  return { set: i, update: h, subscribe: U };\n}\nconst be = (e) => {\n  const { subscribe: n, set: t } = _(null);\n  let o = null;\n  return n((i) => o = i), e.observe(({ changes: i }) => {\n    if (o) {\n      i.deleted.some((b) => b.id === o) && t(null);\n      const U = i.updated.find(({ oldValue: b }) => b.id === o);\n      U && t(U.newValue.id);\n    }\n  }), {\n    get current() {\n      return o;\n    },\n    subscribe: n,\n    set: t\n  };\n};\nvar q = /* @__PURE__ */ ((e) => (e.EDIT = \"EDIT\", e.SELECT = \"SELECT\", e.NONE = \"NONE\", e))(q || {});\nconst V = { selected: [] }, ve = (e, n = \"EDIT\") => {\n  const { subscribe: t, set: o } = _(V);\n  let i = V;\n  t((s) => i = s);\n  const h = () => o(V), U = () => {\n    var s;\n    return ((s = i.selected) == null ? void 0 : s.length) === 0;\n  }, b = (s) => {\n    if (i.selected.length === 0)\n      return !1;\n    const f = typeof s == \"string\" ? s : s.id;\n    return i.selected.some((y) => y.id === f);\n  }, w = (s, f) => {\n    const y = e.getAnnotation(s);\n    if (y) {\n      const A = G(y, n);\n      o(A === \"EDIT\" ? { selected: [{ id: s, editable: !0 }], pointerEvent: f } : A === \"SELECT\" ? { selected: [{ id: s }], pointerEvent: f } : { selected: [], pointerEvent: f });\n    } else\n      console.warn(\"Invalid selection: \" + s);\n  }, u = (s, f = !0) => {\n    const y = Array.isArray(s) ? s : [s], A = y.map((L) => e.getAnnotation(L)).filter((L) => L);\n    o({ selected: A.map(({ id: L }) => ({ id: L, editable: f })) }), A.length !== y.length && console.warn(\"Invalid selection\", s);\n  }, T = (s) => {\n    if (i.selected.length === 0)\n      return !1;\n    const { selected: f } = i;\n    f.filter(({ id: A }) => s.includes(A)).length > 0 && o({ selected: f.filter(({ id: A }) => !s.includes(A)) });\n  };\n  return e.observe(({ changes: s }) => T(s.deleted.map((f) => f.id))), {\n    clear: h,\n    clickSelect: w,\n    get selected() {\n      return i ? [...i.selected] : null;\n    },\n    get pointerEvent() {\n      return i ? i.pointerEvent : null;\n    },\n    isEmpty: U,\n    isSelected: b,\n    setSelected: u,\n    subscribe: t\n  };\n}, G = (e, n) => typeof n == \"function\" ? n(e) || \"EDIT\" : n || \"EDIT\";\nlet z;\nconst H = new Uint8Array(16);\nfunction F() {\n  if (!z && (z = typeof crypto < \"u\" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !z))\n    throw new Error(\"crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\");\n  return z(H);\n}\nconst R = [];\nfor (let e = 0; e < 256; ++e)\n  R.push((e + 256).toString(16).slice(1));\nfunction J(e, n = 0) {\n  return R[e[n + 0]] + R[e[n + 1]] + R[e[n + 2]] + R[e[n + 3]] + \"-\" + R[e[n + 4]] + R[e[n + 5]] + \"-\" + R[e[n + 6]] + R[e[n + 7]] + \"-\" + R[e[n + 8]] + R[e[n + 9]] + \"-\" + R[e[n + 10]] + R[e[n + 11]] + R[e[n + 12]] + R[e[n + 13]] + R[e[n + 14]] + R[e[n + 15]];\n}\nconst Q = typeof crypto < \"u\" && crypto.randomUUID && crypto.randomUUID.bind(crypto), j = {\n  randomUUID: Q\n};\nfunction X(e, n, t) {\n  if (j.randomUUID && !n && !e)\n    return j.randomUUID();\n  e = e || {};\n  const o = e.random || (e.rng || F)();\n  if (o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, n) {\n    t = t || 0;\n    for (let i = 0; i < 16; ++i)\n      n[t + i] = o[i];\n    return n;\n  }\n  return J(o);\n}\nconst Ce = (e) => {\n  const { creator: n, updatedBy: t } = e.target, o = e.bodies.reduce((i, h) => [...i, h.creator, h.updatedBy], []);\n  return [\n    n,\n    t,\n    ...o\n  ].filter((i) => i);\n}, we = (e, n, t, o) => ({\n  id: X(),\n  annotation: e.id,\n  created: t || /* @__PURE__ */ new Date(),\n  creator: o,\n  ...n\n}), Z = (e, n) => {\n  const t = new Set(e.bodies.map((o) => o.id));\n  return n.bodies.filter((o) => !t.has(o.id));\n}, K = (e, n) => {\n  const t = new Set(n.bodies.map((o) => o.id));\n  return e.bodies.filter((o) => !t.has(o.id));\n}, ee = (e, n) => n.bodies.map((t) => {\n  const o = e.bodies.find((i) => i.id === t.id);\n  return { newBody: t, oldBody: o && !B(o, t) ? o : void 0 };\n}).filter(({ oldBody: t }) => t), te = (e, n) => !B(e.target, n.target), M = (e, n) => {\n  const t = Z(e, n), o = K(e, n), i = ee(e, n);\n  return {\n    oldValue: e,\n    newValue: n,\n    bodiesCreated: t.length > 0 ? t : void 0,\n    bodiesDeleted: o.length > 0 ? o : void 0,\n    bodiesUpdated: i.length > 0 ? i : void 0,\n    targetUpdated: te(e, n) ? { oldTarget: e.target, newTarget: n.target } : void 0\n  };\n};\nvar ne = /* @__PURE__ */ ((e) => (e.BODY_ONLY = \"BODY_ONLY\", e.TARGET_ONLY = \"TARGET_ONLY\", e))(ne || {}), O = /* @__PURE__ */ ((e) => (e.LOCAL = \"LOCAL\", e.REMOTE = \"REMOTE\", e))(O || {});\nconst oe = (e, n) => {\n  var h, U;\n  const { changes: t, origin: o } = n;\n  if (!(!e.options.origin || e.options.origin === o))\n    return !1;\n  if (e.options.ignore) {\n    const { ignore: b } = e.options, w = (T) => (T == null ? void 0 : T.length) > 0;\n    if (!(w(t.created) || w(t.deleted))) {\n      const T = (h = t.updated) == null ? void 0 : h.some((f) => w(f.bodiesCreated) || w(f.bodiesDeleted) || w(f.bodiesUpdated)), s = (U = t.updated) == null ? void 0 : U.some((f) => f.targetUpdated);\n      if (b === \"BODY_ONLY\" && T && !s || b === \"TARGET_ONLY\" && s && !T)\n        return !1;\n    }\n  }\n  if (e.options.annotations) {\n    const b = /* @__PURE__ */ new Set([\n      ...t.created.map((u) => u.id),\n      ...t.deleted.map((u) => u.id),\n      ...t.updated.map(({ oldValue: u }) => u.id)\n    ]);\n    return !!(Array.isArray(e.options.annotations) ? e.options.annotations : [e.options.annotations]).find((u) => b.has(u));\n  } else\n    return !0;\n}, se = (e, n) => {\n  const t = new Set((e.created || []).map((s) => s.id)), o = new Set((e.updated || []).map(({ newValue: s }) => s.id)), i = new Set((n.created || []).map((s) => s.id)), h = new Set((n.deleted || []).map((s) => s.id)), U = new Set((n.updated || []).map(({ oldValue: s }) => s.id)), b = new Set((n.updated || []).filter(({ oldValue: s }) => t.has(s.id) || o.has(s.id)).map(({ oldValue: s }) => s.id)), w = [\n    ...(e.created || []).filter((s) => !h.has(s.id)).map((s) => U.has(s.id) ? n.updated.find(({ oldValue: f }) => f.id === s.id).newValue : s),\n    ...n.created || []\n  ], u = [\n    ...(e.deleted || []).filter((s) => !i.has(s.id)),\n    ...(n.deleted || []).filter((s) => !t.has(s.id))\n  ], T = [\n    ...(e.updated || []).filter(({ newValue: s }) => !h.has(s.id)).map((s) => {\n      const { oldValue: f, newValue: y } = s;\n      if (U.has(y.id)) {\n        const A = n.updated.find((L) => L.oldValue.id === y.id).newValue;\n        return M(f, A);\n      } else\n        return s;\n    }),\n    ...(n.updated || []).filter(({ oldValue: s }) => !b.has(s.id))\n  ];\n  return { created: w, deleted: u, updated: T };\n}, ie = (e) => e.id !== void 0, ye = () => {\n  const e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map(), t = [], o = (r, l = {}) => t.push({ onChange: r, options: l }), i = (r) => {\n    const l = t.findIndex((a) => a.onChange == r);\n    l > -1 && t.splice(l, 1);\n  }, h = (r, l) => {\n    const a = {\n      origin: r,\n      changes: {\n        created: l.created || [],\n        updated: l.updated || [],\n        deleted: l.deleted || []\n      },\n      state: [...e.values()]\n    };\n    t.forEach((p) => {\n      oe(p, a) && p.onChange(a);\n    });\n  }, U = (r, l = O.LOCAL) => {\n    if (e.get(r.id))\n      throw Error(`Cannot add annotation ${r.id} - exists already`);\n    e.set(r.id, r), r.bodies.forEach((p) => n.set(p.id, r.id)), h(l, { created: [r] });\n  }, b = (r, l) => {\n    const a = typeof r == \"string\" ? l : r, p = typeof r == \"string\" ? r : r.id, v = e.get(p);\n    if (v) {\n      const D = M(v, a);\n      return p === a.id ? e.set(p, a) : (e.delete(p), e.set(a.id, a)), v.bodies.forEach((x) => n.delete(x.id)), a.bodies.forEach((x) => n.set(x.id, a.id)), D;\n    } else\n      console.warn(`Cannot update annotation ${p} - does not exist`);\n  }, w = (r, l = O.LOCAL, a = O.LOCAL) => {\n    const p = ie(l) ? a : l, v = b(r, l);\n    v && h(p, { updated: [v] });\n  }, u = (r, l = O.LOCAL) => {\n    const a = r.reduce((p, v) => {\n      const D = b(v);\n      return D ? [...p, D] : p;\n    }, []);\n    a.length > 0 && h(l, { updated: a });\n  }, T = (r, l = O.LOCAL) => {\n    const a = e.get(r.annotation);\n    if (a) {\n      const p = {\n        ...a,\n        bodies: [...a.bodies, r]\n      };\n      e.set(a.id, p), n.set(r.id, p.id), h(l, { updated: [{\n        oldValue: a,\n        newValue: p,\n        bodiesCreated: [r]\n      }] });\n    } else\n      console.warn(`Attempt to add body to missing annotation: ${r.annotation}`);\n  }, s = () => [...e.values()], f = (r = O.LOCAL) => {\n    const l = [...e.values()];\n    e.clear(), n.clear(), h(r, { deleted: l });\n  }, y = (r, l = !0, a = O.LOCAL) => {\n    if (l) {\n      const p = [...e.values()];\n      e.clear(), n.clear(), r.forEach((v) => {\n        e.set(v.id, v), v.bodies.forEach((D) => n.set(D.id, v.id));\n      }), h(a, { created: r, deleted: p });\n    } else {\n      const p = r.reduce((v, D) => {\n        const x = e.get(D.id);\n        return x ? [...v, x] : v;\n      }, []);\n      if (p.length > 0)\n        throw Error(`Bulk insert would overwrite the following annotations: ${p.map((v) => v.id).join(\", \")}`);\n      r.forEach((v) => {\n        e.set(v.id, v), v.bodies.forEach((D) => n.set(D.id, v.id));\n      }), h(a, { created: r });\n    }\n  }, A = (r) => {\n    const l = typeof r == \"string\" ? r : r.id, a = e.get(l);\n    if (a)\n      return e.delete(l), a.bodies.forEach((p) => n.delete(p.id)), a;\n    console.warn(`Attempt to delete missing annotation: ${l}`);\n  }, L = (r, l = O.LOCAL) => {\n    const a = A(r);\n    a && h(l, { deleted: [a] });\n  }, C = (r, l = O.LOCAL) => {\n    const a = r.reduce((p, v) => {\n      const D = A(v);\n      return D ? [...p, D] : p;\n    }, []);\n    a.length > 0 && h(l, { deleted: a });\n  }, c = (r, l = O.LOCAL) => {\n    const a = e.get(r.annotation);\n    if (a) {\n      const p = a.bodies.find((v) => v.id === r.id);\n      if (p) {\n        n.delete(p.id);\n        const v = {\n          ...a,\n          bodies: a.bodies.filter((x) => x.id !== r.id)\n        };\n        e.set(a.id, v), h(l, { updated: [{\n          oldValue: a,\n          newValue: v,\n          bodiesDeleted: [p]\n        }] });\n      } else\n        console.warn(`Attempt to delete missing body ${r.id} from annotation ${r.annotation}`);\n    } else\n      console.warn(`Attempt to delete body from missing annotation ${r.annotation}`);\n  }, m = (r) => {\n    const l = e.get(r);\n    return l ? { ...l } : void 0;\n  }, d = (r) => {\n    const l = n.get(r);\n    if (l) {\n      const p = m(l).bodies.find((v) => v.id === r);\n      if (p)\n        return p;\n      console.error(`Store integrity error: body ${r} in index, but not in annotation`);\n    } else\n      console.warn(`Attempt to retrieve missing body: ${r}`);\n  }, E = (r, l) => {\n    if (r.annotation !== l.annotation)\n      throw \"Annotation integrity violation: annotation ID must be the same when updating bodies\";\n    const a = e.get(r.annotation);\n    if (a) {\n      const p = a.bodies.find((D) => D.id === r.id), v = {\n        ...a,\n        bodies: a.bodies.map((D) => D.id === p.id ? l : D)\n      };\n      return e.set(a.id, v), p.id !== l.id && (n.delete(p.id), n.set(l.id, v.id)), {\n        oldValue: a,\n        newValue: v,\n        bodiesUpdated: [{ oldBody: p, newBody: l }]\n      };\n    } else\n      console.warn(`Attempt to add body to missing annotation ${r.annotation}`);\n  }, g = (r, l, a = O.LOCAL) => {\n    const p = E(r, l);\n    h(a, { updated: [p] });\n  }, S = (r, l = O.LOCAL) => {\n    const a = r.map((p) => E({ id: p.id, annotation: p.annotation }, p));\n    h(l, { updated: a });\n  }, I = (r) => {\n    const l = e.get(r.annotation);\n    if (l) {\n      const a = {\n        ...l,\n        target: {\n          ...l.target,\n          ...r\n        }\n      };\n      return e.set(l.id, a), {\n        oldValue: l,\n        newValue: a,\n        targetUpdated: {\n          oldTarget: l.target,\n          newTarget: r\n        }\n      };\n    } else\n      console.warn(`Attempt to update target on missing annotation: ${r.annotation}`);\n  };\n  return {\n    addAnnotation: U,\n    addBody: T,\n    all: s,\n    bulkAddAnnotation: y,\n    bulkDeleteAnnotation: C,\n    bulkUpdateAnnotation: u,\n    bulkUpdateBodies: S,\n    bulkUpdateTargets: (r, l = O.LOCAL) => {\n      const a = r.map(I).filter((p) => p);\n      a.length > 0 && h(l, { updated: a });\n    },\n    clear: f,\n    deleteAnnotation: L,\n    deleteBody: c,\n    getAnnotation: m,\n    getBody: d,\n    observe: o,\n    unobserve: i,\n    updateAnnotation: w,\n    updateBody: g,\n    updateTarget: (r, l = O.LOCAL) => {\n      const a = I(r);\n      a && h(l, { updated: [a] });\n    }\n  };\n}, Ue = (e) => ({\n  ...e,\n  subscribe: (t) => {\n    const o = (i) => t(i.state);\n    return e.observe(o), t(e.all()), () => e.unobserve(o);\n  }\n});\nlet P = () => ({\n  emit(e, ...n) {\n    let t = this.events[e] || [];\n    for (let o = 0, i = t.length; o < i; o++)\n      t[o](...n);\n  },\n  events: {},\n  on(e, n) {\n    var t;\n    return (t = this.events[e]) != null && t.push(n) || (this.events[e] = [n]), () => {\n      var o;\n      this.events[e] = (o = this.events[e]) == null ? void 0 : o.filter((i) => n !== i);\n    };\n  }\n});\nconst de = 250, Le = (e) => {\n  const n = P(), t = [];\n  let o = -1, i = !1, h = 0;\n  const U = (d) => {\n    if (!i) {\n      const { changes: E } = d, g = performance.now();\n      if (g - h > de)\n        t.splice(o + 1), t.push(E), o = t.length - 1;\n      else {\n        const S = t.length - 1;\n        t[S] = se(t[S], E);\n      }\n      h = g;\n    }\n    i = !1;\n  };\n  e.observe(U, { origin: O.LOCAL });\n  const b = (d) => (d == null ? void 0 : d.length) > 0 && e.bulkDeleteAnnotation(d), w = (d) => (d == null ? void 0 : d.length) > 0 && e.bulkAddAnnotation(d, !1), u = (d) => (d == null ? void 0 : d.length) > 0 && e.bulkUpdateAnnotation(d.map(({ oldValue: E }) => E)), T = (d) => (d == null ? void 0 : d.length) > 0 && e.bulkUpdateAnnotation(d.map(({ newValue: E }) => E)), s = (d) => (d == null ? void 0 : d.length) > 0 && e.bulkAddAnnotation(d, !1), f = (d) => (d == null ? void 0 : d.length) > 0 && e.bulkDeleteAnnotation(d);\n  return {\n    canRedo: () => t.length - 1 > o,\n    canUndo: () => o > -1,\n    destroy: () => e.unobserve(U),\n    on: (d, E) => n.on(d, E),\n    redo: () => {\n      if (t.length - 1 > o) {\n        i = !0;\n        const { created: d, updated: E, deleted: g } = t[o + 1];\n        w(d), T(E), f(g), n.emit(\"redo\", t[o + 1]), o += 1;\n      }\n    },\n    undo: () => {\n      if (o > -1) {\n        i = !0;\n        const { created: d, updated: E, deleted: g } = t[o];\n        b(d), u(E), s(g), n.emit(\"undo\", t[o]), o -= 1;\n      }\n    }\n  };\n}, Se = () => {\n  const { subscribe: e, set: n } = _([]);\n  return {\n    subscribe: e,\n    set: n\n  };\n}, Te = (e, n, t, o) => {\n  const { store: i, selection: h, hover: U, viewport: b } = e, w = /* @__PURE__ */ new Map();\n  let u = [], T, s;\n  const f = (c, m) => {\n    w.has(c) ? w.get(c).push(m) : w.set(c, [m]);\n  }, y = (c, m) => {\n    const d = w.get(c);\n    d && d.indexOf(m) > 0 && d.splice(d.indexOf(m), 1);\n  }, A = (c, m, d) => {\n    w.has(c) && setTimeout(() => {\n      w.get(c).forEach((E) => {\n        if (t) {\n          const g = Array.isArray(m) ? m.map((I) => t.serialize(I)) : t.serialize(m), S = d ? d instanceof PointerEvent ? d : t.serialize(d) : void 0;\n          E(g, S);\n        } else\n          E(m, d);\n      });\n    }, 1);\n  }, L = () => {\n    const { selected: c } = h, m = c.map(({ id: d }) => i.getAnnotation(d));\n    m.forEach((d) => {\n      const E = u.find((g) => g.id === d.id);\n      (!E || !B(E, d)) && A(\"updateAnnotation\", d, E);\n    }), u = u.map((d) => {\n      const E = m.find(({ id: g }) => g === d.id);\n      return E || d;\n    });\n  };\n  h.subscribe(({ selected: c }) => {\n    if (!(u.length === 0 && c.length === 0)) {\n      if (u.length === 0 && c.length > 0)\n        u = c.map(({ id: m }) => i.getAnnotation(m));\n      else if (u.length > 0 && c.length === 0)\n        u.forEach((m) => {\n          const d = i.getAnnotation(m.id);\n          d && !B(d, m) && A(\"updateAnnotation\", d, m);\n        }), u = [];\n      else {\n        const m = new Set(u.map((g) => g.id)), d = new Set(c.map(({ id: g }) => g));\n        u.filter((g) => !d.has(g.id)).forEach((g) => {\n          const S = i.getAnnotation(g.id);\n          S && !B(S, g) && A(\"updateAnnotation\", S, g);\n        }), u = [\n          // Remove annotations that were deselected\n          ...u.filter((g) => d.has(g.id)),\n          // Add editable annotations that were selected\n          ...c.filter(({ id: g }) => !m.has(g)).map(({ id: g }) => i.getAnnotation(g))\n        ];\n      }\n      A(\"selectionChanged\", u);\n    }\n  }), U.subscribe((c) => {\n    !T && c ? A(\"mouseEnterAnnotation\", i.getAnnotation(c)) : T && !c ? A(\"mouseLeaveAnnotation\", i.getAnnotation(T)) : T && c && (A(\"mouseLeaveAnnotation\", i.getAnnotation(T)), A(\"mouseEnterAnnotation\", i.getAnnotation(c))), T = c;\n  }), b == null || b.subscribe((c) => A(\"viewportIntersect\", c.map(i.getAnnotation))), i.observe((c) => {\n    o && (s && clearTimeout(s), s = setTimeout(L, 1e3));\n    const { created: m, deleted: d } = c.changes;\n    m.forEach((g) => A(\"createAnnotation\", g)), d.forEach((g) => A(\"deleteAnnotation\", g)), c.changes.updated.filter((g) => [\n      ...g.bodiesCreated || [],\n      ...g.bodiesDeleted || [],\n      ...g.bodiesUpdated || []\n    ].length > 0).forEach(({ oldValue: g, newValue: S }) => {\n      const I = u.find((N) => N.id === g.id) || g;\n      u = u.map((N) => N.id === g.id ? S : N), A(\"updateAnnotation\", S, I);\n    });\n  }, { origin: O.LOCAL }), i.observe((c) => {\n    if (u) {\n      const m = new Set(u.map((E) => E.id)), d = c.changes.updated.filter(({ newValue: E }) => m.has(E.id)).map(({ newValue: E }) => E);\n      d.length > 0 && (u = u.map((E) => {\n        const g = d.find((S) => S.id === E.id);\n        return g || E;\n      }));\n    }\n  }, { origin: O.REMOTE });\n  const C = (c) => (m) => {\n    const { created: d, deleted: E, updated: g } = m;\n    d.forEach((S) => A(\"createAnnotation\", S)), E.forEach((S) => A(\"deleteAnnotation\", S)), c ? g.forEach((S) => A(\"updateAnnotation\", S.oldValue, S.newValue)) : g.forEach((S) => A(\"updateAnnotation\", S.newValue, S.oldValue));\n  };\n  return n.on(\"undo\", C(!0)), n.on(\"redo\", C(!1)), { on: f, off: y, emit: A };\n}, Oe = (e) => (n) => n.map((t) => e.serialize(t)), re = (e) => (n) => n.reduce((t, o) => {\n  const { parsed: i, error: h } = e.parse(o);\n  return h ? {\n    parsed: t.parsed,\n    failed: [...t.failed, o]\n  } : {\n    parsed: [...t.parsed, i],\n    failed: t.failed\n  };\n}, { parsed: [], failed: [] }), De = (e, n, t) => {\n  const { store: o, selection: i } = e, h = (C) => {\n    if (t) {\n      const { parsed: c, error: m } = t.parse(C);\n      c ? o.addAnnotation(c, O.REMOTE) : console.error(m);\n    } else\n      o.addAnnotation(C, O.REMOTE);\n  }, U = () => i.clear(), b = () => o.clear(), w = (C) => {\n    const c = o.getAnnotation(C);\n    return t && c ? t.serialize(c) : c;\n  }, u = () => t ? o.all().map(t.serialize) : o.all(), T = () => {\n    var m;\n    const c = (((m = i.selected) == null ? void 0 : m.map((d) => d.id)) || []).map((d) => o.getAnnotation(d));\n    return t ? c.map(t.serialize) : c;\n  }, s = (C) => fetch(C).then((c) => c.json()).then((c) => (y(c), c)), f = (C) => {\n    if (typeof C == \"string\") {\n      const c = o.getAnnotation(C);\n      return o.deleteAnnotation(C), t ? t.serialize(c) : c;\n    } else {\n      const c = t ? t.parse(C).parsed : C;\n      return o.deleteAnnotation(c), C;\n    }\n  }, y = (C) => {\n    if (t) {\n      const { parsed: c, failed: m } = re(t)(C);\n      m.length > 0 && console.warn(`Discarded ${m.length} invalid annotations`, m), o.bulkAddAnnotation(c, !0, O.REMOTE);\n    } else\n      o.bulkAddAnnotation(C, !0, O.REMOTE);\n  }, A = (C) => {\n    C ? i.setSelected(C) : i.clear();\n  }, L = (C) => {\n    if (t) {\n      const c = t.parse(C).parsed, m = t.serialize(o.getAnnotation(c.id));\n      return o.updateAnnotation(c), m;\n    } else {\n      const c = o.getAnnotation(C.id);\n      return o.updateAnnotation(C), c;\n    }\n  };\n  return {\n    addAnnotation: h,\n    cancelSelected: U,\n    canRedo: n.canRedo,\n    canUndo: n.canUndo,\n    clearAnnotations: b,\n    getAnnotationById: w,\n    getAnnotations: u,\n    getSelected: T,\n    loadAnnotations: s,\n    redo: n.redo,\n    removeAnnotation: f,\n    setAnnotations: y,\n    setSelected: A,\n    undo: n.undo,\n    updateAnnotation: L\n  };\n};\nlet ae = (e) => crypto.getRandomValues(new Uint8Array(e)), ce = (e, n, t) => {\n  let o = (2 << Math.log(e.length - 1) / Math.LN2) - 1, i = -~(1.6 * o * n / e.length);\n  return (h = n) => {\n    let U = \"\";\n    for (; ; ) {\n      let b = t(i), w = i;\n      for (; w--; )\n        if (U += e[b[w] & o] || \"\", U.length === h)\n          return U;\n    }\n  };\n}, le = (e, n = 21) => ce(e, n, ae), ue = (e = 21) => crypto.getRandomValues(new Uint8Array(e)).reduce((n, t) => (t &= 63, t < 36 ? n += t.toString(36) : t < 62 ? n += (t - 26).toString(36).toUpperCase() : t > 62 ? n += \"-\" : n += \"_\", n), \"\");\nconst Re = () => ({ isGuest: !0, id: le(\"1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_\", 20)() }), fe = (e) => {\n  const n = JSON.stringify(e);\n  let t = 0;\n  for (let o = 0, i = n.length; o < i; o++) {\n    let h = n.charCodeAt(o);\n    t = (t << 5) - t + h, t |= 0;\n  }\n  return `${t}`;\n}, pe = (e) => e ? typeof e == \"object\" ? { ...e } : e : void 0, xe = (e, n) => (Array.isArray(e) ? e : [e]).map((t) => {\n  const { id: o, type: i, purpose: h, value: U, created: b, creator: w, ...u } = t;\n  return {\n    id: o || `temp-${fe(t)}`,\n    annotation: n,\n    type: i,\n    purpose: h,\n    value: U,\n    created: b ? new Date(b) : void 0,\n    creator: pe(w),\n    ...u\n  };\n}), Be = (e) => e.map((n) => {\n  var o;\n  const t = { ...n };\n  return delete t.annotation, (o = t.id) != null && o.startsWith(\"temp-\") && delete t.id, t;\n}), he = [\n  \"#ff7c00\",\n  // orange\n  \"#1ac938\",\n  // green\n  \"#e8000b\",\n  // red\n  \"#8b2be2\",\n  // purple\n  \"#9f4800\",\n  // brown\n  \"#f14cc1\",\n  // pink\n  \"#ffc400\",\n  // khaki\n  \"#00d7ff\",\n  // cyan\n  \"#023eff\"\n  // blue\n], ge = () => {\n  const e = [...he];\n  return { assignRandomColor: () => {\n    const o = Math.floor(Math.random() * e.length), i = e[o];\n    return e.splice(o, 1), i;\n  }, releaseColor: (o) => e.push(o) };\n}, me = () => {\n  const e = ge();\n  return { addUser: (o, i) => {\n    const h = e.assignRandomColor();\n    return {\n      label: i.name || i.id,\n      avatar: i.avatar,\n      color: h\n    };\n  }, removeUser: (o) => e.releaseColor(o.appearance.color) };\n}, Ae = (e, n) => e.every((t) => e.includes(t)) && n.every((t) => e.includes(t)), Ie = ue(), ke = (e = me()) => {\n  const n = P(), t = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), i = (s, f) => {\n    if (t.has(s)) {\n      console.warn(\"Attempt to add user that is already present\", s, f);\n      return;\n    }\n    const y = e.addUser(s, f);\n    t.set(s, {\n      ...f,\n      presenceKey: s,\n      appearance: y\n    });\n  }, h = (s) => {\n    const f = t.get(s);\n    if (!f) {\n      console.warn(\"Attempt to remove user that is not present\", s);\n      return;\n    }\n    e.removeUser(f), t.delete(s);\n  }, U = (s) => {\n    const f = new Set(s.map((L) => L.presenceKey)), y = s.filter(({ presenceKey: L }) => !t.has(L)), A = Array.from(t.values()).filter((L) => !f.has(L.presenceKey));\n    y.forEach(({ presenceKey: L, user: C }) => i(L, C)), A.forEach((L) => {\n      const { presenceKey: C } = L;\n      o.has(C) && n.emit(\"selectionChange\", L, null), h(C);\n    }), (y.length > 0 || A.length > 0) && n.emit(\"presence\", u());\n  }, b = (s, f) => {\n    const y = t.get(s);\n    if (!y) {\n      console.warn(\"Activity notification from user that is not present\");\n      return;\n    }\n    const A = o.get(s);\n    (!A || !Ae(A, f)) && (o.set(s, f), n.emit(\"selectionChange\", y, f));\n  }, w = (s, f) => {\n    const y = t.get(s);\n    if (!y) {\n      console.warn(\"Selection change for user that is not present\", s);\n      return;\n    }\n    f ? o.set(s, f) : o.delete(s), n.emit(\"selectionChange\", y, f);\n  }, u = () => [...Array.from(t.values())];\n  return {\n    getPresentUsers: u,\n    notifyActivity: b,\n    on: (s, f) => n.on(s, f),\n    syncUsers: U,\n    updateSelection: w\n  };\n};\nexport {\n  ne as Ignore,\n  O as Origin,\n  Ie as PRESENCE_KEY,\n  q as PointerSelectAction,\n  Re as createAnonymousGuest,\n  De as createBaseAnnotator,\n  we as createBody,\n  me as createDefaultAppearenceProvider,\n  be as createHoverState,\n  Te as createLifecyleObserver,\n  ke as createPresenceState,\n  ve as createSelectionState,\n  ye as createStore,\n  Le as createUndoStack,\n  Se as createViewportState,\n  ge as defaultColorProvider,\n  M as diffAnnotations,\n  Ce as getContributors,\n  se as mergeChanges,\n  G as onPointerSelect,\n  re as parseAll,\n  xe as parseW3CBodies,\n  pe as parseW3CUser,\n  Oe as serializeAll,\n  Be as serializeW3CBodies,\n  oe as shouldNotify,\n  Ue as toSvelteStore\n};\n//# sourceMappingURL=annotorious-core.es.js.map\n"],"names":["q","e","z","H","F","R","J","n","Q","j","X","t","o","i","we","O","ae","ce","h","U","b","w","le","ue","Re","he","ge"],"mappings":"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","x_google_ignoreList":[0]}